"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebRenderModalWithLoader = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const studio_shared_1 = require("@remotion/studio-shared");
const web_renderer_1 = require("@remotion/web-renderer");
const react_1 = require("react");
const ShortcutHint_1 = require("../../error-overlay/remotion-overlay/ShortcutHint");
const data_1 = require("../../icons/data");
const file_1 = require("../../icons/file");
const frame_1 = require("../../icons/frame");
const Button_1 = require("../Button");
const is_menu_item_1 = require("../Menu/is-menu-item");
const ModalHeader_1 = require("../ModalHeader");
const DismissableModal_1 = require("../NewComposition/DismissableModal");
const SegmentedControl_1 = require("../SegmentedControl");
const vertical_1 = require("../Tabs/vertical");
const DataEditor_1 = require("./DataEditor");
const get_string_before_suffix_1 = require("./get-string-before-suffix");
const render_modals_1 = require("./render-modals");
const ResolveCompositionBeforeModal_1 = require("./ResolveCompositionBeforeModal");
const WebRenderModalAdvanced_1 = require("./WebRenderModalAdvanced");
const WebRenderModalBasic_1 = require("./WebRenderModalBasic");
const WebRenderModalPicture_1 = require("./WebRenderModalPicture");
const invalidCharacters = ['?', '*', '+', ':', '%'];
const isValidStillExtension = (extension, stillImageFormat) => {
    if (stillImageFormat === 'jpeg' && extension === 'jpg') {
        return true;
    }
    return extension === stillImageFormat;
};
const validateOutnameForStill = ({ outName, stillImageFormat, }) => {
    try {
        const extension = outName.substring(outName.lastIndexOf('.') + 1);
        const prefix = outName.substring(0, outName.lastIndexOf('.'));
        const hasDotAfterSlash = () => {
            const substrings = prefix.split('/');
            for (const str of substrings) {
                if (str[0] === '.') {
                    return true;
                }
            }
            return false;
        };
        const hasInvalidChar = () => {
            return prefix.split('').some((char) => invalidCharacters.includes(char));
        };
        if (prefix.length < 1) {
            throw new Error('The prefix must be at least 1 character long');
        }
        if (prefix[0] === '.' || hasDotAfterSlash()) {
            throw new Error('The output name must not start with a dot');
        }
        if (hasInvalidChar()) {
            throw new Error("Filename can't contain the following characters:  ?, *, +, %, :");
        }
        if (!isValidStillExtension(extension, stillImageFormat)) {
            throw new Error(`The extension ${extension} is not supported for still image format ${stillImageFormat}`);
        }
        return { valid: true };
    }
    catch (err) {
        return { valid: false, error: err };
    }
};
// TODO: Add to queue
// TODO: Switch to server-side rendering
// TODO: Filter out codecs that are not supported for the container
// TODO: Add more containers
// TODO: Shortcut: Shift + R
// TODO: Apply defaultCodec
// TODO: Apply defaultOutName
const WebRenderModal = ({ initialFrame, defaultProps, inFrameMark, outFrameMark, }) => {
    const context = (0, react_1.useContext)(ResolveCompositionBeforeModal_1.ResolvedCompositionContext);
    if (!context) {
        throw new Error('Should not be able to render without resolving comp first');
    }
    const { resolved: { result: resolvedComposition }, unresolved: unresolvedComposition, } = context;
    const [renderMode, setRenderMode] = (0, react_1.useState)('video');
    const [tab, setTab] = (0, react_1.useState)('general');
    const [imageFormat, setImageFormat] = (0, react_1.useState)('png');
    const [frame, setFrame] = (0, react_1.useState)(() => initialFrame);
    const [logLevel, setLogLevel] = (0, react_1.useState)('info');
    const [inputProps, setInputProps] = (0, react_1.useState)(() => defaultProps);
    const [delayRenderTimeout, setDelayRenderTimeout] = (0, react_1.useState)(30000);
    const [mediaCacheSizeInBytes, setMediaCacheSizeInBytes] = (0, react_1.useState)(null);
    const [saving, setSaving] = (0, react_1.useState)(false);
    // Video-specific state
    const [codec, setCodec] = (0, react_1.useState)('h264');
    const [container, setContainer] = (0, react_1.useState)('mp4');
    const [videoBitrate, setVideoBitrate] = (0, react_1.useState)('high');
    const [hardwareAcceleration, setHardwareAcceleration] = (0, react_1.useState)('no-preference');
    const [keyframeIntervalInSeconds, setKeyframeIntervalInSeconds] = (0, react_1.useState)(5);
    const [startFrame, setStartFrame] = (0, react_1.useState)(() => inFrameMark !== null && inFrameMark !== void 0 ? inFrameMark : null);
    const [endFrame, setEndFrame] = (0, react_1.useState)(() => outFrameMark !== null && outFrameMark !== void 0 ? outFrameMark : null);
    const [renderProgress, setRenderProgress] = (0, react_1.useState)(null);
    const [transparent, setTransparent] = (0, react_1.useState)(false);
    const finalEndFrame = (0, react_1.useMemo)(() => {
        if (endFrame === null) {
            return resolvedComposition.durationInFrames - 1;
        }
        return Math.max(0, Math.min(resolvedComposition.durationInFrames - 1, endFrame));
    }, [endFrame, resolvedComposition.durationInFrames]);
    const finalStartFrame = (0, react_1.useMemo)(() => {
        if (startFrame === null) {
            return 0;
        }
        return Math.max(0, Math.min(finalEndFrame, startFrame));
    }, [finalEndFrame, startFrame]);
    const frameRange = (0, react_1.useMemo)(() => {
        if (startFrame === null && endFrame === null) {
            return null;
        }
        return [finalStartFrame, finalEndFrame];
    }, [endFrame, finalEndFrame, finalStartFrame, startFrame]);
    const [initialOutName] = (0, react_1.useState)(() => {
        return (0, studio_shared_1.getDefaultOutLocation)({
            compositionName: resolvedComposition.id,
            defaultExtension: container,
            type: 'asset',
            compositionDefaultOutName: resolvedComposition.defaultOutName,
            clientSideRender: true,
        });
    });
    const [outName, setOutName] = (0, react_1.useState)(() => initialOutName);
    const setStillFormat = (0, react_1.useCallback)((format) => {
        setImageFormat(format);
        setOutName((prev) => {
            const newFileName = (0, get_string_before_suffix_1.getStringBeforeSuffix)(prev) + '.' + format;
            return newFileName;
        });
    }, []);
    const setContainerFormat = (0, react_1.useCallback)((newContainer) => {
        setContainer(newContainer);
        setOutName((prev) => {
            const newFileName = (0, get_string_before_suffix_1.getStringBeforeSuffix)(prev) + '.' + newContainer;
            return newFileName;
        });
    }, []);
    const onRenderModeChange = (0, react_1.useCallback)((newMode) => {
        setRenderMode(newMode);
        if (newMode === 'video') {
            setOutName((prev) => {
                const newFileName = (0, get_string_before_suffix_1.getStringBeforeSuffix)(prev) + '.' + container;
                return newFileName;
            });
        }
        else {
            setOutName((prev) => {
                const newFileName = (0, get_string_before_suffix_1.getStringBeforeSuffix)(prev) + '.' + imageFormat;
                return newFileName;
            });
        }
    }, [container, imageFormat]);
    const renderTabOptions = (0, react_1.useMemo)(() => {
        const options = [
            {
                label: 'Still',
                onClick: () => {
                    onRenderModeChange('still');
                },
                key: 'still',
                selected: renderMode === 'still',
            },
        ];
        // Only show video option if composition has more than 1 frame
        if (resolvedComposition.durationInFrames > 1) {
            options.push({
                label: 'Video',
                onClick: () => {
                    onRenderModeChange('video');
                },
                key: 'video',
                selected: renderMode === 'video',
            });
        }
        return options;
    }, [renderMode, resolvedComposition.durationInFrames, onRenderModeChange]);
    const onFrameSetDirectly = (0, react_1.useCallback)((newFrame) => {
        setFrame(newFrame);
    }, [setFrame]);
    const onFrameChanged = (0, react_1.useCallback)((e) => {
        setFrame((q) => {
            const newFrame = parseFloat(e);
            if (Number.isNaN(newFrame)) {
                return q;
            }
            return newFrame;
        });
    }, [setFrame]);
    const onOutNameChange = (0, react_1.useCallback)((e) => {
        setOutName(e.target.value);
    }, []);
    const outnameValidation = (0, react_1.useMemo)(() => {
        if (renderMode === 'still') {
            return validateOutnameForStill({
                outName,
                stillImageFormat: imageFormat,
            });
        }
        // Validate for video
        try {
            const extension = outName.substring(outName.lastIndexOf('.') + 1);
            const prefix = outName.substring(0, outName.lastIndexOf('.'));
            const hasDotAfterSlash = () => {
                const substrings = prefix.split('/');
                for (const str of substrings) {
                    if (str[0] === '.') {
                        return true;
                    }
                }
                return false;
            };
            const hasInvalidChar = () => {
                return prefix
                    .split('')
                    .some((char) => invalidCharacters.includes(char));
            };
            if (prefix.length < 1) {
                throw new Error('The prefix must be at least 1 character long');
            }
            if (prefix[0] === '.' || hasDotAfterSlash()) {
                throw new Error('The output name must not start with a dot');
            }
            if (hasInvalidChar()) {
                throw new Error("Filename can't contain the following characters:  ?, *, +, %, :");
            }
            if (extension !== container) {
                throw new Error(`The extension ${extension} is not supported for container format ${container}`);
            }
            return { valid: true };
        }
        catch (err) {
            return { valid: false, error: err };
        }
    }, [outName, imageFormat, renderMode, container]);
    const onRenderStill = (0, react_1.useCallback)(async () => {
        const blob = await (0, web_renderer_1.renderStillOnWeb)({
            composition: {
                component: unresolvedComposition.component,
                width: resolvedComposition.width,
                height: resolvedComposition.height,
                fps: resolvedComposition.fps,
                durationInFrames: resolvedComposition.durationInFrames,
                defaultProps: resolvedComposition.defaultProps,
                calculateMetadata: unresolvedComposition.calculateMetadata,
                id: resolvedComposition.id,
            },
            frame,
            imageFormat,
            inputProps,
            delayRenderTimeoutInMilliseconds: delayRenderTimeout,
            mediaCacheSizeInBytes,
            logLevel,
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        // Extract just the filename from the path
        const filename = outName.includes('/')
            ? outName.substring(outName.lastIndexOf('/') + 1)
            : outName;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }, [
        unresolvedComposition.component,
        frame,
        imageFormat,
        logLevel,
        inputProps,
        delayRenderTimeout,
        mediaCacheSizeInBytes,
        resolvedComposition.durationInFrames,
        resolvedComposition.width,
        resolvedComposition.height,
        resolvedComposition.fps,
        outName,
        resolvedComposition.defaultProps,
        unresolvedComposition.calculateMetadata,
        resolvedComposition.id,
    ]);
    const onRenderVideo = (0, react_1.useCallback)(async () => {
        setRenderProgress({ renderedFrames: 0, encodedFrames: 0 });
        const buffer = await (0, web_renderer_1.renderMediaOnWeb)({
            composition: {
                component: unresolvedComposition.component,
                width: resolvedComposition.width,
                height: resolvedComposition.height,
                fps: resolvedComposition.fps,
                durationInFrames: resolvedComposition.durationInFrames,
                defaultProps: resolvedComposition.defaultProps,
                id: resolvedComposition.id,
                calculateMetadata: unresolvedComposition.calculateMetadata,
            },
            inputProps,
            delayRenderTimeoutInMilliseconds: delayRenderTimeout,
            mediaCacheSizeInBytes,
            logLevel,
            codec,
            container,
            videoBitrate,
            hardwareAcceleration,
            keyframeIntervalInSeconds,
            frameRange,
            onProgress: (progress) => {
                setRenderProgress(progress);
            },
            transparent,
        });
        setRenderProgress(null);
        const blob = new Blob([buffer], {
            type: container === 'mp4' ? 'video/mp4' : 'video/webm',
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        // Extract just the filename from the path
        const filename = outName.includes('/')
            ? outName.substring(outName.lastIndexOf('/') + 1)
            : outName;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }, [
        unresolvedComposition.component,
        inputProps,
        delayRenderTimeout,
        mediaCacheSizeInBytes,
        logLevel,
        codec,
        container,
        videoBitrate,
        hardwareAcceleration,
        keyframeIntervalInSeconds,
        frameRange,
        resolvedComposition.durationInFrames,
        resolvedComposition.width,
        resolvedComposition.height,
        resolvedComposition.fps,
        outName,
        transparent,
        resolvedComposition.defaultProps,
        resolvedComposition.id,
        unresolvedComposition.calculateMetadata,
    ]);
    const onRender = (0, react_1.useCallback)(async () => {
        if (renderMode === 'still') {
            await onRenderStill();
        }
        else {
            await onRenderVideo();
        }
    }, [renderMode, onRenderStill, onRenderVideo]);
    return ((0, jsx_runtime_1.jsxs)("div", { style: render_modals_1.outerModalStyle, children: [(0, jsx_runtime_1.jsx)(ModalHeader_1.ModalHeader, { title: `Render ${resolvedComposition.id}` }), (0, jsx_runtime_1.jsxs)("div", { style: render_modals_1.container, children: [(0, jsx_runtime_1.jsx)(SegmentedControl_1.SegmentedControl, { items: renderTabOptions, needsWrapping: false }), (0, jsx_runtime_1.jsx)("div", { style: render_modals_1.flexer }), (0, jsx_runtime_1.jsxs)(Button_1.Button, { autoFocus: true, onClick: onRender, style: render_modals_1.buttonStyle, disabled: !outnameValidation.valid, children: [renderProgress
                                ? `Rendering... ${renderProgress.renderedFrames}/${finalEndFrame}`
                                : `Render ${renderMode}`, (0, jsx_runtime_1.jsx)(ShortcutHint_1.ShortcutHint, { keyToPress: "\u21B5", cmdOrCtrl: true })] })] }), (0, jsx_runtime_1.jsxs)("div", { style: render_modals_1.horizontalLayout, children: [(0, jsx_runtime_1.jsxs)("div", { style: render_modals_1.leftSidebar, children: [(0, jsx_runtime_1.jsxs)(vertical_1.VerticalTab, { style: render_modals_1.horizontalTab, selected: tab === 'general', onClick: () => setTab('general'), children: [(0, jsx_runtime_1.jsx)("div", { style: render_modals_1.iconContainer, children: (0, jsx_runtime_1.jsx)(file_1.FileIcon, { style: render_modals_1.icon }) }), "General"] }), (0, jsx_runtime_1.jsxs)(vertical_1.VerticalTab, { style: render_modals_1.horizontalTab, selected: tab === 'data', onClick: () => setTab('data'), children: [(0, jsx_runtime_1.jsx)("div", { style: render_modals_1.iconContainer, children: (0, jsx_runtime_1.jsx)(data_1.DataIcon, { style: render_modals_1.icon }) }), "Input Props"] }), renderMode === 'video' ? ((0, jsx_runtime_1.jsxs)(vertical_1.VerticalTab, { style: render_modals_1.horizontalTab, selected: tab === 'picture', onClick: () => setTab('picture'), children: [(0, jsx_runtime_1.jsx)("div", { style: render_modals_1.iconContainer, children: (0, jsx_runtime_1.jsx)(frame_1.PicIcon, { style: render_modals_1.icon }) }), "Picture"] })) : null, (0, jsx_runtime_1.jsxs)(vertical_1.VerticalTab, { style: render_modals_1.horizontalTab, selected: tab === 'advanced', onClick: () => setTab('advanced'), children: [(0, jsx_runtime_1.jsx)("div", { style: render_modals_1.iconContainer, children: (0, jsx_runtime_1.jsx)(file_1.FileIcon, { style: render_modals_1.icon }) }), "Advanced"] })] }), (0, jsx_runtime_1.jsx)("div", { style: render_modals_1.optionsPanel, className: is_menu_item_1.VERTICAL_SCROLLBAR_CLASSNAME, children: tab === 'general' ? ((0, jsx_runtime_1.jsx)(WebRenderModalBasic_1.WebRenderModalBasic, { renderMode: renderMode, resolvedComposition: resolvedComposition, imageFormat: imageFormat, setStillFormat: setStillFormat, frame: frame, onFrameChanged: onFrameChanged, onFrameSetDirectly: onFrameSetDirectly, container: container, setContainerFormat: setContainerFormat, codec: codec, setCodec: setCodec, startFrame: finalStartFrame, setStartFrame: setStartFrame, endFrame: finalEndFrame, setEndFrame: setEndFrame, outName: outName, onOutNameChange: onOutNameChange, validationMessage: outnameValidation.valid ? null : outnameValidation.error.message, logLevel: logLevel, setLogLevel: setLogLevel })) : tab === 'data' ? ((0, jsx_runtime_1.jsx)(DataEditor_1.DataEditor, { defaultProps: inputProps, setDefaultProps: setInputProps, unresolvedComposition: unresolvedComposition, mayShowSaveButton: false, propsEditType: "input-props", saving: saving, setSaving: setSaving, readOnlyStudio: false })) : tab === 'picture' ? ((0, jsx_runtime_1.jsx)(WebRenderModalPicture_1.WebRenderModalPicture, { renderMode: renderMode, videoBitrate: videoBitrate, setVideoBitrate: setVideoBitrate, keyframeIntervalInSeconds: keyframeIntervalInSeconds, setKeyframeIntervalInSeconds: setKeyframeIntervalInSeconds, transparent: transparent, setTransparent: setTransparent })) : ((0, jsx_runtime_1.jsx)(WebRenderModalAdvanced_1.WebRenderModalAdvanced, { renderMode: renderMode, delayRenderTimeout: delayRenderTimeout, setDelayRenderTimeout: setDelayRenderTimeout, mediaCacheSizeInBytes: mediaCacheSizeInBytes, setMediaCacheSizeInBytes: setMediaCacheSizeInBytes, hardwareAcceleration: hardwareAcceleration, setHardwareAcceleration: setHardwareAcceleration })) })] })] }));
};
const WebRenderModalWithLoader = (props) => {
    return ((0, jsx_runtime_1.jsx)(DismissableModal_1.DismissableModal, { children: (0, jsx_runtime_1.jsx)(ResolveCompositionBeforeModal_1.ResolveCompositionBeforeModal, { compositionId: props.compositionId, children: (0, jsx_runtime_1.jsx)(WebRenderModal, { ...props }) }) }));
};
exports.WebRenderModalWithLoader = WebRenderModalWithLoader;
