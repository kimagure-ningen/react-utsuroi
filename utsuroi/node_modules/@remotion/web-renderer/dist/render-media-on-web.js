import { BufferTarget, Output, VideoSample, VideoSampleSource } from 'mediabunny';
import { Internals } from 'remotion';
import { handleArtifacts } from './artifact';
import { createScaffold } from './create-scaffold';
import { getRealFrameRange } from './frame-range';
import { codecToMediabunnyCodec, containerToMediabunnyContainer, getDefaultVideoCodecForContainer, getQualityForWebRendererQuality, } from './mediabunny-mappings';
import { createFrame } from './take-screenshot';
import { createThrottledProgressCallback } from './throttle-progress';
import { validateVideoFrame } from './validate-video-frame';
import { waitForReady } from './wait-for-ready';
// TODO: More containers
// TODO: Audio
// TODO: Metadata
// TODO: Validating inputs
// TODO: Web file system API
// TODO: Apply defaultCodec
const internalRenderMediaOnWeb = async ({ composition, inputProps, delayRenderTimeoutInMilliseconds, logLevel, mediaCacheSizeInBytes, schema, codec, container, signal, onProgress, hardwareAcceleration, keyframeIntervalInSeconds, videoBitrate, frameRange, transparent, onArtifact, onFrame, }) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const cleanupFns = [];
    const format = containerToMediabunnyContainer(container);
    if (codec &&
        !format.getSupportedCodecs().includes(codecToMediabunnyCodec(codec))) {
        return Promise.reject(new Error(`Codec ${codec} is not supported for container ${container}`));
    }
    const resolved = await Internals.resolveVideoConfig({
        calculateMetadata: (_a = composition.calculateMetadata) !== null && _a !== void 0 ? _a : null,
        signal: signal !== null && signal !== void 0 ? signal : new AbortController().signal,
        defaultProps: (_b = composition.defaultProps) !== null && _b !== void 0 ? _b : {},
        inputProps: inputProps !== null && inputProps !== void 0 ? inputProps : {},
        compositionId: composition.id,
        compositionDurationInFrames: (_c = composition.durationInFrames) !== null && _c !== void 0 ? _c : null,
        compositionFps: (_d = composition.fps) !== null && _d !== void 0 ? _d : null,
        compositionHeight: (_e = composition.height) !== null && _e !== void 0 ? _e : null,
        compositionWidth: (_f = composition.width) !== null && _f !== void 0 ? _f : null,
    });
    const realFrameRange = getRealFrameRange(resolved.durationInFrames, frameRange);
    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
        return Promise.reject(new Error('renderMediaOnWeb() was cancelled'));
    }
    const { delayRenderScope, div, cleanupScaffold, timeUpdater, collectAssets } = await createScaffold({
        width: resolved.width,
        height: resolved.height,
        fps: resolved.fps,
        durationInFrames: resolved.durationInFrames,
        Component: composition.component,
        resolvedProps: resolved.props,
        id: resolved.id,
        delayRenderTimeoutInMilliseconds,
        logLevel,
        mediaCacheSizeInBytes,
        schema: schema !== null && schema !== void 0 ? schema : null,
        audioEnabled: true,
        videoEnabled: true,
        initialFrame: 0,
        defaultCodec: resolved.defaultCodec,
        defaultOutName: resolved.defaultOutName,
    });
    const artifactsHandler = handleArtifacts({
        ref: collectAssets,
        onArtifact,
    });
    cleanupFns.push(() => {
        cleanupScaffold();
    });
    const output = new Output({
        format,
        target: new BufferTarget(),
    });
    try {
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderMediaOnWeb() was cancelled');
        }
        await waitForReady({
            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds,
            scope: delayRenderScope,
            signal,
            apiName: 'renderMediaOnWeb',
        });
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderMediaOnWeb() was cancelled');
        }
        cleanupFns.push(() => {
            if (output.state === 'finalized' || output.state === 'canceled') {
                return;
            }
            output.cancel();
        });
        const videoSampleSource = new VideoSampleSource({
            codec: codecToMediabunnyCodec(codec),
            bitrate: typeof videoBitrate === 'number'
                ? videoBitrate
                : getQualityForWebRendererQuality(videoBitrate),
            sizeChangeBehavior: 'deny',
            hardwareAcceleration,
            latencyMode: 'quality',
            keyFrameInterval: keyframeIntervalInSeconds,
            alpha: transparent ? 'keep' : 'discard',
        });
        cleanupFns.push(() => {
            videoSampleSource.close();
        });
        output.addVideoTrack(videoSampleSource);
        await output.start();
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderMediaOnWeb() was cancelled');
        }
        const progress = {
            renderedFrames: 0,
            encodedFrames: 0,
        };
        const throttledOnProgress = createThrottledProgressCallback(onProgress);
        for (let i = realFrameRange[0]; i <= realFrameRange[1]; i++) {
            (_g = timeUpdater.current) === null || _g === void 0 ? void 0 : _g.update(i);
            await waitForReady({
                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds,
                scope: delayRenderScope,
                signal,
                apiName: 'renderMediaOnWeb',
            });
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error('renderMediaOnWeb() was cancelled');
            }
            const imageData = await createFrame({
                div,
                width: resolved.width,
                height: resolved.height,
            });
            await artifactsHandler.handle({ imageData, frame: i });
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error('renderMediaOnWeb() was cancelled');
            }
            const timestamp = Math.round(((i - realFrameRange[0]) / resolved.fps) * 1000000);
            const videoFrame = new VideoFrame(imageData, {
                timestamp,
            });
            progress.renderedFrames++;
            throttledOnProgress === null || throttledOnProgress === void 0 ? void 0 : throttledOnProgress({ ...progress });
            // Process frame through onFrame callback if provided
            let frameToEncode = videoFrame;
            if (onFrame) {
                const returnedFrame = await onFrame(videoFrame);
                frameToEncode = validateVideoFrame({
                    originalFrame: videoFrame,
                    returnedFrame,
                    expectedWidth: resolved.width,
                    expectedHeight: resolved.height,
                    expectedTimestamp: timestamp,
                });
            }
            await videoSampleSource.add(new VideoSample(frameToEncode));
            progress.encodedFrames++;
            throttledOnProgress === null || throttledOnProgress === void 0 ? void 0 : throttledOnProgress({ ...progress });
            frameToEncode.close();
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error('renderMediaOnWeb() was cancelled');
            }
        }
        // Call progress one final time to ensure final state is reported
        onProgress === null || onProgress === void 0 ? void 0 : onProgress({ ...progress });
        videoSampleSource.close();
        await output.finalize();
        return output.target.buffer;
    }
    finally {
        cleanupFns.forEach((fn) => fn());
    }
};
export const renderMediaOnWeb = (options) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const container = (_a = options.container) !== null && _a !== void 0 ? _a : 'mp4';
    const codec = (_b = options.codec) !== null && _b !== void 0 ? _b : getDefaultVideoCodecForContainer(container);
    return internalRenderMediaOnWeb({
        ...options,
        delayRenderTimeoutInMilliseconds: (_c = options.delayRenderTimeoutInMilliseconds) !== null && _c !== void 0 ? _c : 30000,
        logLevel: (_d = options.logLevel) !== null && _d !== void 0 ? _d : 'info',
        schema: (_e = options.schema) !== null && _e !== void 0 ? _e : undefined,
        mediaCacheSizeInBytes: (_f = options.mediaCacheSizeInBytes) !== null && _f !== void 0 ? _f : null,
        codec,
        container,
        signal: (_g = options.signal) !== null && _g !== void 0 ? _g : null,
        onProgress: (_h = options.onProgress) !== null && _h !== void 0 ? _h : null,
        hardwareAcceleration: (_j = options.hardwareAcceleration) !== null && _j !== void 0 ? _j : 'no-preference',
        keyframeIntervalInSeconds: (_k = options.keyframeIntervalInSeconds) !== null && _k !== void 0 ? _k : 5,
        videoBitrate: (_l = options.videoBitrate) !== null && _l !== void 0 ? _l : 'medium',
        frameRange: (_m = options.frameRange) !== null && _m !== void 0 ? _m : null,
        transparent: (_o = options.transparent) !== null && _o !== void 0 ? _o : false,
        onArtifact: (_p = options.onArtifact) !== null && _p !== void 0 ? _p : null,
        onFrame: (_q = options.onFrame) !== null && _q !== void 0 ? _q : null,
    });
};
