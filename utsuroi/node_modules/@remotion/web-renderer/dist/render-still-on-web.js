import { Internals, } from 'remotion';
import { handleArtifacts } from './artifact';
import { createScaffold } from './create-scaffold';
import { takeScreenshot } from './take-screenshot';
import { waitForReady } from './wait-for-ready';
async function internalRenderStillOnWeb({ frame, delayRenderTimeoutInMilliseconds, logLevel, inputProps, schema, imageFormat, mediaCacheSizeInBytes, composition, signal, onArtifact, }) {
    var _a, _b, _c, _d, _e, _f;
    const resolved = await Internals.resolveVideoConfig({
        calculateMetadata: (_a = composition.calculateMetadata) !== null && _a !== void 0 ? _a : null,
        signal: signal !== null && signal !== void 0 ? signal : new AbortController().signal,
        defaultProps: (_b = composition.defaultProps) !== null && _b !== void 0 ? _b : {},
        inputProps: inputProps !== null && inputProps !== void 0 ? inputProps : {},
        compositionId: composition.id,
        compositionDurationInFrames: (_c = composition.durationInFrames) !== null && _c !== void 0 ? _c : null,
        compositionFps: (_d = composition.fps) !== null && _d !== void 0 ? _d : null,
        compositionHeight: (_e = composition.height) !== null && _e !== void 0 ? _e : null,
        compositionWidth: (_f = composition.width) !== null && _f !== void 0 ? _f : null,
    });
    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
        return Promise.reject(new Error('renderStillOnWeb() was cancelled'));
    }
    const { delayRenderScope, div, cleanupScaffold, collectAssets } = await createScaffold({
        width: resolved.width,
        height: resolved.height,
        delayRenderTimeoutInMilliseconds,
        logLevel,
        resolvedProps: resolved.props,
        id: resolved.id,
        mediaCacheSizeInBytes,
        audioEnabled: false,
        Component: composition.component,
        videoEnabled: true,
        durationInFrames: resolved.durationInFrames,
        fps: resolved.fps,
        schema: schema !== null && schema !== void 0 ? schema : null,
        initialFrame: frame,
        defaultCodec: resolved.defaultCodec,
        defaultOutName: resolved.defaultOutName,
    });
    const artifactsHandler = handleArtifacts({
        ref: collectAssets,
        onArtifact,
    });
    try {
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderStillOnWeb() was cancelled');
        }
        await waitForReady({
            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds,
            scope: delayRenderScope,
            signal,
            apiName: 'renderStillOnWeb',
        });
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            throw new Error('renderStillOnWeb() was cancelled');
        }
        const imageData = await takeScreenshot({
            div,
            width: resolved.width,
            height: resolved.height,
            imageFormat,
        });
        await artifactsHandler.handle({ imageData, frame });
        return imageData;
    }
    finally {
        cleanupScaffold();
    }
}
export const renderStillOnWeb = (options) => {
    var _a, _b, _c, _d, _e, _f;
    return internalRenderStillOnWeb({
        ...options,
        delayRenderTimeoutInMilliseconds: (_a = options.delayRenderTimeoutInMilliseconds) !== null && _a !== void 0 ? _a : 30000,
        logLevel: (_b = options.logLevel) !== null && _b !== void 0 ? _b : 'info',
        schema: (_c = options.schema) !== null && _c !== void 0 ? _c : undefined,
        mediaCacheSizeInBytes: (_d = options.mediaCacheSizeInBytes) !== null && _d !== void 0 ? _d : null,
        signal: (_e = options.signal) !== null && _e !== void 0 ? _e : null,
        onArtifact: (_f = options.onArtifact) !== null && _f !== void 0 ? _f : null,
    });
};
